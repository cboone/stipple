# v0.4 Implementation Plan: Circle Drawing

Add circle drawing to brodot using Bresenham's midpoint circle algorithm.

## Deliverables

1. `draw/circle.go` - Circle and CircleFilled functions
2. `draw/circle_test.go` - Comprehensive test suite
3. Updated `examples/demo/main.go` - Circle demonstrations

---

## 1. Create `draw/circle.go`

### Functions

```go
// Circle draws a circle outline centered at (centerX, centerY) with the given radius.
// Radius of 0 draws a single pixel at the center.
// Negative radius draws nothing.
func Circle(c *canvas.Canvas, centerX, centerY, radius float64)

// CircleFilled draws a filled circle centered at (centerX, centerY) with the given radius.
// Radius of 0 draws a single pixel at the center.
// Negative radius draws nothing.
func CircleFilled(c *canvas.Canvas, centerX, centerY, radius float64)
```

### Algorithm: Bresenham's Midpoint Circle

**Key concepts:**
- Decision parameter `d = 1 - radius` determines whether to step east or southeast
- 8-way symmetry: compute one octant, plot all 8 symmetric points
- Iterate while `x < y` (first octant only)

**Circle outline pseudocode:**
```
x = 0, y = radius, d = 1 - radius
plotSymmetricPoints(cx, cy, x, y)
while x < y:
    x++
    if d < 0:
        d = d + 2*x + 1        // move east
    else:
        y--
        d = d + 2*(x - y) + 1  // move southeast
    plotSymmetricPoints(cx, cy, x, y)
```

**8 symmetric points for each (x, y):**
```go
c.Set(cx+x, cy+y)   c.Set(cx-x, cy+y)
c.Set(cx+x, cy-y)   c.Set(cx-x, cy-y)
c.Set(cx+y, cy+x)   c.Set(cx-y, cy+x)
c.Set(cx+y, cy-x)   c.Set(cx-y, cy-x)
```

**CircleFilled approach:**
- Draw 4 horizontal spans at each iteration covering all octants
- Simpler than gap-avoidance logic; some overdraw is acceptable

```
while x <= y:
    drawHorizontalSpan(cx-x, cx+x, cy+y)
    drawHorizontalSpan(cx-x, cx+x, cy-y)
    drawHorizontalSpan(cx-y, cx+y, cy+x)
    drawHorizontalSpan(cx-y, cx+y, cy-x)
    // ... update x, y, d
```

### Edge Cases

| Case | Behavior |
|------|----------|
| radius = 0 | Draw single pixel at center |
| radius < 0 | Draw nothing (early return) |
| Off-canvas | Let canvas.Set() silently clip |

### Patterns to Follow (from rectangle.go)

- Convert float64 to int using `math.Floor()` at function entry
- Convert back to float64 when calling `c.Set()`
- Early return for invalid input (radius < 0)
- Use descriptive variable names for public API parameters
- Helper functions: `plotCirclePoints()`, `drawHorizontalSpan()`

---

## 2. Create `draw/circle_test.go`

Use shared `test_helpers_test.go` (already has `printVisual()` and flag setup).

### Test Cases

| Test | Purpose |
|------|---------|
| TestCircleSymmetry | Verify 8-way symmetry for outline |
| TestCircleRadius0 | Radius 0 draws exactly 1 pixel |
| TestCircleRadius1 | Small circle has 4 cardinal points |
| TestCircleNegativeRadius | Negative radius draws nothing |
| TestCircleFloatCoordinates | Float coords properly floored |
| TestCirclePartiallyOffCanvas | Circle at corner clips correctly |
| TestCircleFilled | Interior pixels are set |
| TestCircleFilledNoGaps | Scan rows to verify no gaps |
| TestCircleOutlineOnly | Outline circle has empty interior |
| TestCircleFilledNegativeRadius | Nothing drawn |

### Test Patterns

```go
func TestCircleOutlineOnly(t *testing.T) {
    c := canvas.New(30, 30)
    Circle(c, 14, 14, 10)

    // Interior should NOT be set
    if c.Get(14, 14) {
        t.Error("center should not be set in outline")
    }

    printVisual(t, "TestCircleOutlineOnly", c)
}
```

### Helper Function

```go
func countSetPixels(c *canvas.Canvas, width, height int) int {
    count := 0
    for y := 0; y < height; y++ {
        for x := 0; x < width; x++ {
            if c.Get(float64(x), float64(y)) {
                count++
            }
        }
    }
    return count
}
```

---

## 3. Update `examples/demo/main.go`

### Changes

1. Update version string to `v0.4.0`
2. Add demos 16-20 after existing rectangle demos

### New Demos

```go
// Demo 16: Circle outline
fmt.Println("16. Circle outline:")
c16 := canvas.New(30, 28)
draw.Circle(c16, 14, 13, 10)
fmt.Println(c16.Frame())
fmt.Println()

// Demo 17: Filled circle
fmt.Println("17. Filled circle:")
c17 := canvas.New(30, 28)
draw.CircleFilled(c17, 14, 13, 10)
fmt.Println(c17.Frame())
fmt.Println()

// Demo 18: Multiple circle sizes
fmt.Println("18. Multiple circle sizes:")
c18 := canvas.New(60, 28)
draw.Circle(c18, 8, 13, 5)
draw.Circle(c18, 25, 13, 8)
draw.Circle(c18, 47, 13, 10)
fmt.Println(c18.Frame())
fmt.Println()

// Demo 19: Concentric circles
fmt.Println("19. Concentric circles:")
c19 := canvas.New(40, 36)
for radius := 2; radius <= 14; radius += 3 {
    draw.Circle(c19, 19, 17, float64(radius))
}
fmt.Println(c19.Frame())
fmt.Println()

// Demo 20: Eyeball sprite (Maze Wars preview)
fmt.Println("20. Eyeball sprite (Maze Wars preview):")
c20 := canvas.New(30, 28)
draw.CircleFilled(c20, 14, 13, 10)  // outer eye
draw.Circle(c20, 16, 12, 5)          // iris
draw.CircleFilled(c20, 17, 11, 2)   // pupil
fmt.Println(c20.Frame())
fmt.Println()
```

---

## Files to Modify

| File | Action |
|------|--------|
| `draw/circle.go` | Create new |
| `draw/circle_test.go` | Create new |
| `examples/demo/main.go` | Add demos 16-20, update version |

---

## Verification

```bash
# Run all tests
go test ./...

# Visual test verification
go test ./draw/... -v -args -visual

# Run demo program
go run ./examples/demo/
```

**Visual checks:**
- Circles appear round (not skewed)
- Filled circles have no gaps
- Outline circles have hollow interiors
- Eyeball sprite looks recognizable
